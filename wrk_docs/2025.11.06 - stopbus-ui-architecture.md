# Stop the Bus Win32 UI Architecture

**Document Date:** 2025-11-06
**Crate:** stopbus-ui (Win32 executable)
**File:** crates/stopbus-ui/src/main.rs (2,571 lines)
**Purpose:** Windows GUI shell using windows-rs for direct Win32 API access

---

## Executive Summary

The `stopbus-ui` crate implements the graphical user interface for "Stop the Bus" using raw Win32 APIs through the `windows-rs` bindings. It provides a faithful recreation of the original 1993 Pascal UI while leveraging modern Rust safety guarantees. The implementation follows traditional Win32 patterns: window classes, message loops, GDI rendering, and Win32 dialogs.

**Key Characteristics:**
1. **Direct Win32 API Usage:** No high-level GUI framework, pure Win32 calls
2. **Message-Driven Architecture:** All interactions handled via WndProc callbacks
3. **Resource Embedding:** Card bitmaps, dialogs, menus embedded at compile time
4. **Legacy Compatibility:** Optionally loads resources from STOPBUS.RES
5. **State Encapsulation:** WindowState struct owns all UI and game state
6. **Registry Persistence:** Window positions and settings saved to Windows Registry

---

## Build System

### build.rs (59 lines)

**Purpose:** Compile-time resource embedding and validation

**Process:**
1. **Check Platform:** Only runs on Windows (`CARGO_CFG_TARGET_OS == "windows"`)
2. **Compile RC File:** `embed-resource` crate compiles `resources/stopbus.rc`
   - Embeds card bitmaps (card01-54.bmp)
   - Embeds dialogs (OPTIONS, ABOUTBOX)
   - Embeds icons (MD.ICO)
   - Embeds version information
3. **Validate Bitmaps:** `assert_modern_bitmap()` checks each BMP file
   - Reads 18-byte header
   - Verifies "BM" magic number
   - Checks DIB header size >= 40 bytes (Windows V3 format)
   - **Fails build** if OS/2 format detected (header < 40)
   - Instructs developer to run `tools/extract_cards.py`
4. **Track Dependencies:** `cargo:rerun-if-changed` for all resources

**Key Function:**
```rust
fn assert_modern_bitmap(path: &Path) {
    // Reads BMP header, extracts DIB size (bytes 14-17)
    // Panics if dib_size < 40 (OS/2 BITMAPCOREHEADER)
}
```

**Output:** Compiled resources linked into executable binary

---

## Architecture Overview

### Main Components

```
┌──────────────────────────────────────────────────────┐
│                   main() Entry Point                  │
│  • Register window classes                           │
│  • Create WindowState                                │
│  • Create main window                                │
│  • Enter message loop (GetMessageW/DispatchMessageW) │
└───────────────────┬──────────────────────────────────┘
                    │
          ┌─────────┴──────────┐
          │                    │
    ┌─────▼─────┐      ┌──────▼──────┐
    │ Main      │      │ Cheat       │
    │ Window    │      │ Windows     │
    └─────┬─────┘      └──────┬──────┘
          │                   │
    window_proc()       cheat_*_wnd_proc()
          │                   │
    ┌─────▼─────────────┬─────▼─────────┐
    │ WM_CREATE         │ WM_PAINT      │
    │ WM_COMMAND        │ WM_MOVE       │
    │ WM_LBUTTONDOWN    │ WM_NCDESTROY  │
    │ WM_LBUTTONUP      │               │
    │ WM_TIMER          │               │
    │ WM_PAINT          │               │
    │ WM_DESTROY        │               │
    │ WM_APP_START      │               │
    └───────────────────┴───────────────┘
```

---

## Core Data Structures

### WindowState (lines 222-280)

**Purpose:** Encapsulates all UI and game state

```rust
struct WindowState {
    // Game Logic
    game: GameState,  // From stopbus-core

    // Resource Handles
    legacy_module: Option<HMODULE>,  // STOPBUS.RES if loaded
    module_instance: HINSTANCE,
    cards: Vec<HBITMAP>,        // Bitmaps 1-52
    card_back: HBITMAP,         // Bitmap 53
    card_cross: HBITMAP,        // Bitmap 54

    // Window Handles
    main_hwnd: Option<HWND>,
    cheat_cards_window: Option<HWND>,
    cheat_stack_window: Option<HWND>,
    cheat_scores_window: Option<HWND>,
    stick_button: Option<HWND>,
    deal_button: Option<HWND>,
    exit_button: Option<HWND>,
    ok_button: Option<HWND>,

    // Options (persisted to Registry)
    options_show_cheat_cards: bool,
    options_show_cheat_stack: bool,
    options_show_cheat_scores: bool,
    options_save_on_exit: bool,

    // Window Positions (persisted to Registry)
    main_window_pos: Option<(i32, i32)>,
    cheat_cards_pos: (i32, i32),
    cheat_stack_pos: (i32, i32),
    cheat_scores_pos: (i32, i32),

    // UI Interaction State
    awaiting_human: bool,
    pending_card: Option<usize>,  // Card slot being clicked
    stack_pressed: bool,          // Stack card clicked

    // Turn Animation
    pending_turns: VecDeque<usize>,
    turn_indicator_override: Option<usize>,
    turn_timer_active: bool,
    automation_pending: bool,
}
```

**Lifecycle:**
1. **Created** in `main()` via `Box::new(WindowState::new(instance)?)`
2. **Stored** in window user data via `SetWindowLongPtrW(GWLP_USERDATA)`
3. **Retrieved** in WndProc via `GetWindowLongPtrW(GWLP_USERDATA)`
4. **Dropped** on WM_NCDESTROY

---

## Constants and Configuration

### Window Dimensions
```rust
const WINDOW_WIDTH: i32 = 600;
const WINDOW_HEIGHT: i32 = 400;
const BACKGROUND_COLOR: u32 = 0x0000_8000;  // Green (RGB)
```

### Card Rendering
```rust
const CARD_WIDTH: i32 = 71;
const CARD_HEIGHT: i32 = 96;
const SMALL_CARD_WIDTH: i32 = 41;   // Cheat windows
const SMALL_CARD_HEIGHT: i32 = 55;
```

### UI Layout Positions
```rust
const STACK_POSITION: (i32, i32) = (10, 40);
const TOP_CARD_POSITION: (i32, i32) = (110, 40);
const PLAYER1_CARD_POSITIONS: [(i32, i32); 3] = [(10, 200), (110, 200), (210, 200)];

const LIVES_HEADING_POSITION: (i32, i32) = (400, 55);
const PLAYER_LABEL_X: i32 = 400;
const PLAYER_LABEL_BASE_Y: i32 = 75;
const PLAYER_LABEL_STEP: i32 = 15;

const BUTTON_STICK_POS: (i32, i32) = (400, 200);
const BUTTON_DEAL_POS: (i32, i32) = (500, 200);
const BUTTON_EXIT_POS: (i32, i32) = (500, 260);
const BUTTON_OK_POS: (i32, i32) = (400, 260);
```

**Matches original Pascal layout exactly (STOPBUS.PAS)**

### Command IDs
```rust
const CM_GAME_DEAL: usize = 100;
const CM_GAME_OPTIONS: usize = 101;
const CM_GAME_EXIT: usize = 102;
const CM_HELP_CONTENTS: usize = 900;
const CM_HELP_ABOUT: usize = 999;

const ID_STICK_BUTTON: usize = 1000;
const ID_DEAL_BUTTON: usize = 1001;
const ID_EXIT_BUTTON: usize = 1002;
const ID_OK_BUTTON: usize = 1003;
```

### Dialog Control IDs
```rust
// Options Dialog
const ID_OPT_CARDS: i32 = 500;
const ID_OPT_STACK: i32 = 501;
const ID_OPT_SCORES: i32 = 502;
const ID_OPT_SAVE_EXIT: i32 = 503;

// About Dialog
const ID_ABOUT_TITLE: i32 = 550;
const ID_ABOUT_COPYRIGHT: i32 = 551;
const ID_ABOUT_LICENSE_NAME: i32 = 552;
const ID_ABOUT_LICENSE_COMPANY: i32 = 553;
const ID_ABOUT_VERSION: i32 = 554;
const ID_ABOUT_RELEASE: i32 = 555;
const ID_ABOUT_ADDRESS: i32 = 556;
```

### Registry Keys
```rust
const REGISTRY_SUBKEY: PCWSTR = w!(r"Software\StopBus\Modernization");

const REG_VALUE_CHEAT_CARDS_VISIBLE: PCWSTR = w!("CheatCardsVisible");
const REG_VALUE_CHEAT_STACK_VISIBLE: PCWSTR = w!("CheatStackVisible");
const REG_VALUE_CHEAT_SCORES_VISIBLE: PCWSTR = w!("CheatScoresVisible");
const REG_VALUE_SAVE_ON_EXIT: PCWSTR = w!("SaveOnExit");

const REG_VALUE_MAIN_WINDOW_POS_X: PCWSTR = w!("MainWindowPosX");
const REG_VALUE_MAIN_WINDOW_POS_Y: PCWSTR = w!("MainWindowPosY");
// ... (cheat window positions)
```

---

## Resource Loading System

### Dual Resource Strategy

**Primary:** Embedded Resources (via embed-resource)
**Fallback:** Legacy STOPBUS.RES (optional runtime loading)

#### Loading Process

**Function:** `WindowState::new()` (lines 283-333)

```rust
impl WindowState {
    fn new(instance: HINSTANCE) -> Result<Self> {
        // 1. Try to load legacy resource module
        let legacy_module = load_legacy_resource_module();

        // 2. Determine resource instance
        let resource_instance = legacy_module
            .map(|module| HINSTANCE(module.0))
            .unwrap_or(instance);  // Fallback to embedded

        // 3. Load card bitmaps (IDs 1-52)
        let mut cards = Vec::with_capacity(52);
        for id in 1..=52 {
            cards.push(unsafe { load_bitmap(resource_instance, id as u16)? });
        }

        // 4. Load special bitmaps (53, 54)
        let card_back = unsafe { load_bitmap(resource_instance, 53)? };
        let card_cross = unsafe { load_bitmap(resource_instance, 54)? };

        // 5. Load settings from Registry
        let options_show_cheat_cards = registry_read_bool(...).unwrap_or(false);
        // ... (other settings)

        // 6. Initialize game state
        let game = GameState::new(None);  // Random seed

        Ok(Self { /* ... */ })
    }
}
```

#### Legacy Resource Module Loading

**Function:** `load_legacy_resource_module()` (lines 1048-1079)

**Algorithm:**
1. Check if `STOPBUS.RES` exists in current directory
2. If exists:
   - `LoadLibraryExW(STOPBUS.RES, LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_IMAGE_RESOURCE)`
   - Returns `Some(HMODULE)`
3. If fails or not found:
   - Log warning (in debug builds)
   - Return `None` (fall back to embedded resources)

**Why This Works:**
- Windows .RES files can be loaded as data-only modules
- Resource APIs work with either module handles
- Allows pixel-perfect legacy compatibility

---

## Window Procedures (WndProc)

### Main Window Procedure

**Function:** `window_proc()` (lines 1242-1561)

**Signature:**
```rust
unsafe extern "system" fn window_proc(
    hwnd: HWND,
    message: u32,
    wparam: WPARAM,
    lparam: LPARAM,
) -> LRESULT
```

**Message Handling:**

#### WM_CREATE (lines 1246-1323)
**Purpose:** Initialize window state

**Actions:**
1. Extract `WindowState` pointer from `CREATESTRUCTW::lpCreateParams`
2. Store in `GWLP_USERDATA` for future access
3. Save `main_hwnd` in state
4. Create menus via `create_menus(hwnd)`
5. Create buttons:
   - "Stick" button (ID_STICK_BUTTON)
   - "Deal" button (ID_DEAL_BUTTON)
   - "Exit" button (ID_EXIT_BUTTON)
   - "OK" button (ID_OK_BUTTON, initially hidden)
6. Register cheat window classes
7. Load window position from Registry (if saved)
8. Apply saved position via `SetWindowPos()`
9. Create cheat windows (if enabled in options)
10. Post `WM_APP_START` to begin game

---

#### WM_APP_START (lines 1325-1342)
**Purpose:** Start game after window fully created

**Actions:**
1. Call `state.game.start_fresh()` → returns `DriveReport`
2. Process events from report:
   - Display each `GameEvent` via `MessageBoxW()`
   - Alert events use `MB_ICONEXCLAMATION`
   - Info events use `MB_ICONINFORMATION`
3. Update `awaiting_human` flag
4. If automation pending (`!report.awaiting_human`):
   - Start turn timer for AI animation
5. Invalidate window to trigger repaint

---

#### WM_COMMAND (lines 1344-1448)
**Purpose:** Handle menu commands and button clicks

**Command Routing:**

**CM_GAME_DEAL (100):**
- Calls `state.game.start_fresh()`
- Processes events
- Refreshes UI

**CM_GAME_OPTIONS (101):**
- Launches Options dialog via `DialogBoxParamW()`
- Passes `state` pointer to dialog proc
- Dialog updates cheat window visibility

**CM_GAME_EXIT (102):**
- Saves settings to Registry (if `options_save_on_exit`)
- Calls `DestroyWindow(hwnd)` → WM_DESTROY → PostQuitMessage

**CM_HELP_CONTENTS (900):**
- Shows "Help not yet implemented" message

**CM_HELP_ABOUT (999):**
- Launches About dialog via `DialogBoxParamW()`

**ID_STICK_BUTTON (1000):**
- Calls `state.game.human_stick()`
- Processes DriveReport
- Continues automation

**ID_DEAL_BUTTON (1001):**
- Advances stack: `state.game.human_draw_next_card()`
- Updates UI
- If successful, updates `awaiting_human` state

**ID_EXIT_BUTTON (1002):**
- Same as CM_GAME_EXIT

**ID_OK_BUTTON (1003):**
- Calls `state.game.advance_after_human_turn()`
- Hides OK button
- Processes AI turns

---

#### WM_LBUTTONDOWN (lines 1450-1485)
**Purpose:** Handle mouse clicks on cards and stack

**Algorithm:**
1. Get mouse position from LPARAM
2. Check if stack card clicked:
   - Compare position with `STACK_POSITION` + card dimensions
   - If hit: set `stack_pressed = true`
3. Check if human hand card clicked:
   - Iterate through `PLAYER1_CARD_POSITIONS`
   - If hit: set `pending_card = Some(slot)`
4. Store for processing on WM_LBUTTONUP

---

#### WM_LBUTTONUP (lines 1487-1522)
**Purpose:** Process card swaps

**Algorithm:**
1. If `stack_pressed`:
   - Clear flag
   - Call `state.game.human_draw_next_card()`
   - Update UI
2. If `pending_card.is_some()`:
   - Get slot index
   - Call `state.game.human_swap_with_stack(slot)`
   - If successful: update scores, refresh UI
   - Clear `pending_card`
3. Invalidate window

---

#### WM_TIMER (lines 1524-1543)
**Purpose:** Animate AI turns with delay

**Algorithm:**
1. Verify timer ID == `TURN_TIMER_ID`
2. Pop next turn from `pending_turns` queue
3. Set `turn_indicator_override` to show AI active
4. Invalidate window (triggers repaint with indicator)
5. If queue empty:
   - Kill timer
   - Clear `automation_pending`
   - If still automation needed: continue via `continue_automation()`

**Timing:** 500ms per turn (TURN_TIMER_INTERVAL_MS)

---

#### WM_PAINT (lines 1545-1548)
**Purpose:** Render game state

**Actions:**
1. Call `paint_main_window(hwnd, state)` (complex rendering logic)
2. All drawing done in BeginPaint/EndPaint block

---

#### WM_DESTROY (lines 1550-1556)
**Purpose:** Clean up and exit

**Actions:**
1. If `options_save_on_exit`:
   - Call `save_options_to_registry(state)`
2. Post `WM_QUIT` to message loop

---

#### WM_NCDESTROY (lines 1558-1560)
**Purpose:** Final cleanup

**Actions:**
1. Retrieve `WindowState` pointer
2. Convert back to `Box<WindowState>`
3. Drop box (Rust Drop trait releases all resources)

---

### Options Dialog Procedure

**Function:** `options_dialog_proc()` (lines 1592-1654)

**Messages:**

**WM_INITDIALOG:**
1. Store `WindowState` pointer in dialog user data
2. Set checkboxes based on current options:
   - `ID_OPT_CARDS` (show cheat cards window)
   - `ID_OPT_STACK` (show cheat stack window)
   - `ID_OPT_SCORES` (show cheat scores window)
   - `ID_OPT_SAVE_EXIT` (save on exit)
3. Return TRUE

**WM_COMMAND (IDOK):**
1. Retrieve checkbox states
2. Update `state.options_*` fields
3. Update cheat window visibility:
   - If enabled and not created: create window
   - If disabled and exists: destroy window
4. Invalidate cheat windows
5. Call `EndDialog(hwnd, IDOK)`

**WM_COMMAND (IDCANCEL):**
- Close dialog without saving

---

### About Dialog Procedure

**Function:** `about_dialog_proc()` (lines 1656-1726)

**WM_INITDIALOG:**
1. Set dialog text fields:
   - `ID_ABOUT_TITLE`: "Stop The Bus"
   - `ID_ABOUT_COPYRIGHT`: "© 1994 M. Davidson / 2025 Modernization"
   - `ID_ABOUT_LICENSE_NAME`: "Rust modernization build."
   - `ID_ABOUT_LICENSE_COMPANY`: "Maintained by the community."
   - `ID_ABOUT_VERSION`: "v2.0"
   - `ID_ABOUT_RELEASE`: "Modernization Release"
   - `ID_ABOUT_ADDRESS`: ""
2. Return TRUE

**WM_COMMAND (IDOK):**
- Close dialog

---

### Cheat Window Procedures

#### Cheat Cards Window (lines 1864-1922)

**Purpose:** Show other players' cards

**WM_PAINT:**
1. Draw each player's (2-4) hand:
   - Render 3 cards per player (scaled to SMALL_CARD dimensions)
   - Show card values from `state.game.hands[player][slot]`
2. Label with player numbers

**WM_MOVE:**
- Save position to `state.cheat_cards_pos`

---

#### Cheat Stack Window (lines 1924-1982)

**Purpose:** Preview upcoming cards in deck

**WM_PAINT:**
1. Get current `stack_index` from game
2. Show next 4 cards (CHEAT_STACK_PREVIEW):
   - `deck[stack_index + 1]` through `deck[stack_index + 4]`
3. Render as small cards with indices

**WM_MOVE:**
- Save position to `state.cheat_stack_pos`

---

#### Cheat Scores Window (lines 1984-2042)

**Purpose:** Show all player scores

**WM_PAINT:**
1. Draw `round_scores` for each player
2. Highlight lowest scorer (red text)
3. Show lives remaining

**WM_MOVE:**
- Save position to `state.cheat_scores_pos`

---

## Rendering System

### Main Window Painting

**Function:** `paint_main_window()` (lines 334-955)

**Algorithm:**

1. **BeginPaint / EndPaint Block**
   - Acquires HDC (device context)
   - Automatic background erase

2. **Background Fill**
   - Create solid brush (BACKGROUND_COLOR = green)
   - FillRect with brush

3. **Draw Deck Label**
   - TextOutW("Deck:", DECK_LABEL_POSITION)

4. **Draw Stack Card**
   - Get stack card from `state.game.stack_top_card()`
   - BitBlt card bitmap to STACK_POSITION

5. **Draw Top Card**
   - BitBlt same card to TOP_CARD_POSITION (user's view)

6. **Draw Hand Label**
   - TextOutW("Your hand:", HAND_LABEL_POSITION)

7. **Draw Human Hand (Player 0)**
   - For each slot in PLAYER1_CARD_POSITIONS:
     - If card exists: BitBlt card bitmap
     - If empty: BitBlt card_cross (X mark)

8. **Draw Lives Panel**
   - TextOutW("Lives:", LIVES_HEADING_POSITION)
   - For each player:
     - TextOutW("Player X: Y", PLAYER_LABEL positions)
     - Show current_player indicator (→)
     - Show stick marker (S) if player stuck

9. **Draw Start Player Indicator**
   - TextOutW("Starting player: X", START_PLAYER_POSITION)

10. **Draw Scores**
    - For each player: show `round_scores[player]`

**GDI Operations Used:**
- `BeginPaint` / `EndPaint`
- `CreateSolidBrush` / `DeleteObject`
- `FillRect`
- `SetTextColor` / `SetBkColor`
- `TextOutW` (Unicode text output)
- `BitBlt` (bitmap blitting)
- `LoadBitmapW` (resource loading)

---

## Persistence (Registry)

### Read Operations

**Function:** `registry_read_dword()` (lines 2056-2079)

**Algorithm:**
1. Call `RegGetValueW(HKEY_CURRENT_USER, REGISTRY_SUBKEY, value_name)`
2. Specify `RRF_RT_REG_DWORD` filter
3. Return `Some(value)` on success, `None` on failure

**Usage:**
- Window positions (X, Y coordinates)
- Checkbox states (via `registry_read_bool()`)

---

### Write Operations

**Function:** `registry_write_dword()` (lines 2080-2092)

**Algorithm:**
1. Call `RegSetKeyValueW(HKEY_CURRENT_USER, REGISTRY_SUBKEY, value_name)`
2. Specify `REG_DWORD` type
3. Write 4-byte value
4. Ignore errors (best-effort persistence)

---

### Save on Exit

**Function:** `save_options_to_registry()` (lines 2103-2271)

**Triggered:** On WM_DESTROY if `options_save_on_exit == true`

**Writes:**
1. Cheat window visibility flags
2. Cheat window positions (X, Y for each)
3. Main window position
4. Save-on-exit flag itself

**Reads on Startup:** All values loaded in `WindowState::new()`

---

## Helper Functions

### String Conversion

**`wide_string(value: &str) -> Vec<u16>` (lines 963-965)**
- Converts UTF-8 Rust &str to null-terminated UTF-16 (Windows Unicode)
- Used for all Win32 text APIs (TextOutW, SetDlgItemTextW, etc.)

**`wide_path(path: &Path) -> Vec<u16>` (lines 956-961)**
- Converts file path to UTF-16
- Uses `OsStrExt::encode_wide()` for Windows paths

---

### Resource ID Conversion

**`make_int_resource(id: u16) -> PCWSTR` (lines 967-969)**
- Converts integer ID to MAKEINTRESOURCEW pointer
- Used for loading embedded resources by ID
- Example: `make_int_resource(1)` → pointer to bitmap ID 1

---

### Drawing Helpers

**`draw_text(hdc: HDC, x: i32, y: i32, text: &str)` (lines 971-999)**
- Wrapper around `TextOutW`
- Converts Rust string to UTF-16
- Handles text length calculation

**`get_mouse_pos(lparam: LPARAM) -> (i32, i32)` (lines 1001-1046)**
- Extracts X, Y coordinates from LPARAM
- Used in WM_LBUTTONDOWN/UP handlers
- Formula:
  - `x = (lparam.0 & 0xFFFF) as i16 as i32`
  - `y = ((lparam.0 >> 16) & 0xFFFF) as i16 as i32`

---

### Window Creation Helpers

**`register_window_class(instance: HINSTANCE)` (lines 1080-1132)**
- Registers main window class ("StopBusMainWindow")
- Sets:
  - `wndproc`: `window_proc`
  - `hInstance`: module instance
  - `hIcon`: App icon (ID 102)
  - `hCursor`: Arrow cursor
  - `style`: `CS_HREDRAW | CS_VREDRAW` (redraw on resize)
  - `hbrBackground`: NULL (manual painting)

**`create_main_window(instance, state_ptr)` (lines 1133-1241)**
- Creates main window via `CreateWindowExW`
- Style: `WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX`
- Size: WINDOW_WIDTH × WINDOW_HEIGHT (600×400)
- Position: CW_USEDEFAULT (or loaded from Registry)
- Passes `state_ptr` in `lpParam` for WM_CREATE

---

### Cheat Window Helpers

**`register_cheat_window_classes(instance, icon)` (lines 1728-1796)**
- Registers 3 window classes:
  - "StopBusCheatCards"
  - "StopBusCheatStack"
  - "StopBusCheatScores"
- Each has custom WndProc
- Style: `WS_EX_TOOLWINDOW` (no taskbar button)

**`create_cheat_*_window(state)` (lines 1797-1826)**
- Creates cheat windows with saved positions
- Sizes from constants (CHEAT_CARDS_SIZE, etc.)
- Initially hidden, shown based on options

---

## Main Entry Point

**Function:** `main()` (lines 2537-2571)

**Algorithm:**

1. **Get Module Handle:**
   ```rust
   let module = GetModuleHandleW(None)?;
   let instance = HINSTANCE(module.0);
   ```

2. **Register Window Class:**
   ```rust
   register_window_class(instance)?;
   ```

3. **Create Window State:**
   ```rust
   let state = Box::new(WindowState::new(instance)?);
   let state_ptr = Box::into_raw(state);  // Leak to heap
   ```

4. **Create Main Window:**
   ```rust
   let hwnd = create_main_window(instance, state_ptr)?;
   ```

5. **Show Window:**
   ```rust
   ShowWindow(hwnd, SW_SHOWDEFAULT);
   ```

6. **Message Loop:**
   ```rust
   let mut message = MSG::default();
   while GetMessageW(&mut message, HWND::default(), 0, 0).into() {
       TranslateMessage(&message);
       DispatchMessageW(&message);
   }
   ```
   - Blocks on `GetMessageW` until message available
   - `TranslateMessage` converts virtual-key messages
   - `DispatchMessageW` calls WndProc

7. **Exit:**
   - Loop exits when `GetMessageW` returns false (WM_QUIT received)
   - WindowState dropped in WM_NCDESTROY

---

## Integration with stopbus-core

### Game State Interaction

**WindowState owns GameState:**
```rust
struct WindowState {
    game: GameState,  // stopbus-core library
    // ...
}
```

**Key Integration Points:**

1. **Start Game:**
   ```rust
   let report = state.game.start_fresh();
   ```

2. **Human Actions:**
   ```rust
   state.game.human_swap_with_stack(slot)?;
   state.game.human_draw_next_card()?;
   state.game.human_stick()?;
   state.game.advance_after_human_turn();
   ```

3. **Query State:**
   ```rust
   state.game.hands[player][slot]
   state.game.deck[stack_index]
   state.game.round_scores[player]
   state.game.lives()
   state.game.current_player()
   ```

4. **Process Events:**
   ```rust
   for event in &report.events {
       let icon = match event.kind {
           MessageKind::Alert => MB_ICONEXCLAMATION,
           MessageKind::Info => MB_ICONINFORMATION,
       };
       MessageBoxW(hwnd, &event.text, w!("Stop The Bus"), icon);
   }
   ```

**Event-Driven Flow:**
- UI calls core methods → returns `DriveReport`
- UI displays `DriveReport.events` to user
- UI updates `awaiting_human` flag
- If automation pending: start timer for AI turns
- On timer tick: show next AI turn, repaint, continue

---

## Dependencies

### External Crates

**`windows = "0.58"` with features:**
- `Win32_Foundation`
- `Win32_UI_WindowsAndMessaging`
- `Win32_Graphics_Gdi`
- `Win32_System_LibraryLoader`
- `Win32_System_Registry`
- `Win32_UI_Input`

**`stopbus-core` (internal)**
- Game logic library
- Provides `GameState`, `DriveReport`, `GameEvent`

**`embed-resource = "3.0"` (build dependency)**
- Compiles .rc resource scripts at build time
- Links resources into executable

**Standard Library:**
- `std::collections::VecDeque` (turn queue)
- `std::ffi::c_void` (raw pointers)
- `std::os::windows::ffi::OsStrExt` (UTF-16 conversion)
- `std::path::Path`
- `std::mem::size_of`
- `std::ptr::copy_nonoverlapping`
- `std::slice`

---

## Comparison with Legacy Pascal

### Architecture Similarities

| Aspect | Pascal (STOPBUS.PAS) | Rust (stopbus-ui) |
|--------|----------------------|-------------------|
| Window class | "TCardApp" | "StopBusMainWindow" |
| Message handling | Virtual methods (CM_*, WM_*) | match on message ID in WndProc |
| State storage | Global arrays + TMainWindow fields | WindowState struct |
| Resource loading | LoadBitmap(ID) | LoadBitmapW(ID) |
| Dialogs | TOptions, TAboutBox (TDialog) | DialogBoxParamW with proc |
| Cheat windows | TCheatCards, TCheatScores, TCheatStack | Separate WndProcs |
| Persistence | INI file (WriteProfileString) | Registry (RegSetKeyValueW) |
| Rendering | BeginPaint/EndPaint, BitBlt | Same (via windows-rs) |

### Modernization Improvements

| Feature | Pascal | Rust |
|---------|--------|------|
| Memory safety | Manual New/Dispose | Automatic Drop trait |
| Resource handles | Manual DeleteObject | Wrapped in structs with Drop |
| String handling | Null-terminated PChar | Vec<u16> (owned) |
| Error handling | Nil checks | Result<T, Error> |
| State encapsulation | Globals + object fields | Single WindowState struct |
| Type safety | Weak (INTEGER, BOOLEAN) | Strong (enums, Options) |
| Platform abstraction | None (Win16/Win32 specific) | windows-rs (safe bindings) |

---

## Technical Debt and Future Improvements

### Current Limitations

1. **No Help System:**
   - `CM_HELP_CONTENTS` shows placeholder message
   - Original used WinHelp (.HLP files, deprecated)
   - **Future:** Implement HTML help viewer (WebView2) or markdown viewer

2. **Single Human Player:**
   - Always player 0
   - No multiplayer support
   - **Consideration:** Would require network code or hot-seat mode

3. **Hardcoded Layout:**
   - Fixed 600×400 window size
   - No DPI scaling
   - **Future:** Calculate positions based on window size

4. **No Undo:**
   - Cannot rewind moves
   - **Future:** Record move history, allow backtracking

5. **Manual Painting:**
   - Redraws entire window on every invalidation
   - **Optimization:** Double buffering, dirty rectangles

### Testing Gaps

1. **No UI Tests:**
   - All testing manual
   - **Future:** UI automation (e.g., WinAppDriver)

2. **Resource Leak Testing:**
   - GDI handles should be tracked
   - **Tool:** GDI Handle Monitor (Task Manager)

3. **Registry Cleanup:**
   - No uninstall cleanup
   - **Future:** Provide uninstall script

### Code Quality Improvements

1. **Error Handling:**
   - Many operations ignore errors (e.g., Registry writes)
   - **Improvement:** Log errors to file or debug console

2. **Magic Numbers:**
   - Some constants could be named better
   - **Refactor:** Extract to semantic constants

3. **Function Length:**
   - `window_proc()` is 319 lines
   - **Refactor:** Extract message handlers to separate functions

---

## Summary

The `stopbus-ui` crate provides a faithful Win32 GUI implementation that successfully bridges the original 1993 Pascal UI with modern Rust safety. It demonstrates effective use of the `windows-rs` crate for direct Win32 API access while maintaining clean separation from game logic via the `stopbus-core` library.

**Strengths:**
- Clean Win32 message-driven architecture
- Faithful recreation of original UI layout
- Dual resource loading (legacy + embedded)
- Comprehensive state management
- Registry persistence for settings
- Cheat windows for debugging

**Architectural Highlights:**
- Single `WindowState` struct encapsulates all UI state
- Message loop follows standard Win32 pattern
- Dialog procedures handle Options and About
- Cheat windows provide developer visibility
- GDI rendering matches Pascal pixel-for-pixel

**Next Steps for Full Parity:**
- Implement modern help system (WebView2 or HTML)
- Add DPI awareness and scaling
- Improve error logging
- Expand test coverage
- Consider double-buffered rendering for smoother UI

---

**Document Created:** 2025-11-06
**Author:** Claude Code (Sonnet 4.5)
