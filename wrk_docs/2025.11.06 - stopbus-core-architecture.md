# Stop the Bus Core Game Logic Architecture

**Document Date:** 2025-11-06
**Crate:** stopbus-core (game logic library)
**File:** crates/stopbus-core/src/lib.rs (1,072 lines)
**Purpose:** Pure Rust implementation of "Stop the Bus" card game logic without UI dependencies

---

## Executive Summary

The `stopbus-core` crate encapsulates all game logic for "Stop the Bus," a 4-player card game ported from 1993 Turbo Pascal. It provides a clean, testable API separating game mechanics from presentation. The implementation preserves the original Pascal scoring rules, AI behavior, and shuffle algorithm while modernizing with Rust's type safety and ownership model.

**Key Design Principles:**
1. **No UI Dependencies:** Pure game logic, no Win32 or graphics code
2. **Deterministic Testing:** Supports seeded RNG for reproducible tests
3. **Event-Driven Architecture:** Returns events for UI to display
4. **Human/AI Differentiation:** Explicit handling for player 0 (human) vs. AI players
5. **State Machine Pattern:** Clear round/turn/game state transitions

---

## Core Data Structures

### Type Aliases and Constants

```rust
pub type CardId = u8;
pub const DECK_SIZE: usize = 52;
pub const PLAYERS: usize = 4;
pub const HAND_SIZE: usize = 3;
```

**CardId Encoding (1-52):**
- **1-13:** Clubs (Ace through King)
- **14-26:** Diamonds (Ace through King)
- **27-39:** Hearts (Ace through King)
- **40-52:** Spades (Ace through King)

This encoding matches the original Pascal implementation exactly for compatibility.

---

### Enums

#### `Suit`
```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Suit {
    Clubs,
    Diamonds,
    Hearts,
    Spades,
}
```

**Purpose:** Represents the four card suits
**Derivations:** Clone, Copy (efficient), Debug (logging), PartialEq/Eq (comparison)
**Usage:** Scoring calculations require matching suits

---

#### `MessageKind`
```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum MessageKind {
    Info,
    Alert,
}
```

**Purpose:** Categorizes game events for UI presentation
**Info:** Normal game flow messages (e.g., "Player 2 lost a life")
**Alert:** Important events requiring attention (e.g., "You've stopped the bus!")

---

#### `FinishResult` (Private)
```rust
enum FinishResult {
    Continue,
    GameOver { winner: Option<usize>, draw: bool },
}
```

**Purpose:** Internal enum for round completion outcomes
**Continue:** Round finished, but game continues (start new round)
**GameOver:** Game finished with winner (Some(player)) or draw (None)
**Visibility:** Private implementation detail, not exposed in public API

---

### Public Structures

#### `GameEvent`
```rust
#[derive(Debug, Clone)]
pub struct GameEvent {
    pub kind: MessageKind,
    pub text: String,
}
```

**Purpose:** Encapsulates game messages for UI display
**Fields:**
- `kind`: Info or Alert (determines UI presentation style)
- `text`: Human-readable message (e.g., "Player 3 has stopped the bus.")

**Factory Methods:**
```rust
pub fn info<T: Into<String>>(text: T) -> Self
pub fn alert<T: Into<String>>(text: T) -> Self
```

**Examples:**
- `GameEvent::info("You lost a life.")`
- `GameEvent::alert("Congratulations - you've won!")`

---

#### `DriveReport`
```rust
#[derive(Debug)]
pub struct DriveReport {
    pub events: Vec<GameEvent>,
    pub awaiting_human: bool,
    pub winner: Option<usize>,
    pub draw: bool,
    pub turn_sequence: Vec<usize>,
}
```

**Purpose:** Returned by all game-advancing methods to communicate state changes to UI

**Fields:**
- **`events`:** Messages generated during this step (e.g., life losses, game over)
- **`awaiting_human`:** True if automation stopped waiting for human player input
- **`winner`:** Some(player_index) if game ended with a winner
- **`draw`:** True if game ended in a draw (all players knocked out simultaneously)
- **`turn_sequence`:** Players who took turns during this step (for UI animation)

**Methods:**
```rust
pub fn game_over(&self) -> bool
```
Returns `true` if `winner.is_some() || draw`

**Usage Pattern:**
```rust
let report = game.start_fresh();
for event in &report.events {
    // Display event.text to user
}
if report.awaiting_human {
    // Enable human interaction UI
} else if report.game_over() {
    // Show game over screen
}
```

---

#### `GameState`
```rust
#[derive(Debug)]
pub struct GameState {
    // Public fields (via getters)
    lives: [u8; PLAYERS],
    pub hands: [[Option<CardId>; HAND_SIZE]; PLAYERS],
    pub deck: [CardId; DECK_SIZE],
    pub round_scores: [u8; PLAYERS],

    // Private game state
    stack_index: usize,
    rng: StdRng,
    current_player: usize,
    round_start_player: usize,
    round_turns: u16,
    stick_player: Option<usize>,
    stick_player_score: Option<u8>,
    pending_new_round: bool,
    stop_player: Option<usize>,
    next_start_candidate: usize,
    finished: bool,

    // Human-specific state
    awaiting_human: bool,
    human_old_stack_card: Option<CardId>,
    human_can_draw_next: bool,
    human_can_stick: bool,
}
```

**Purpose:** Central game state encapsulating all game data

**Field Descriptions:**

**Player State:**
- **`lives`:** Life counters [0..3] for each player (0 = knocked out)
- **`hands`:** Each player's 3-card hand (Option for empty slots)
- **`round_scores`:** Current round scores (0-31, recalculated after swaps)

**Deck State:**
- **`deck`:** Full 52-card deck (shuffled at round start)
- **`stack_index`:** Current position in deck (top card for swapping)

**Round State:**
- **`current_player`:** Active player index (0-3)
- **`round_start_player`:** Who started this round (rotates each round)
- **`round_turns`:** Turn counter (diagnostic)
- **`stick_player`:** Some(player) if someone has stuck
- **`stick_player_score`:** Score when they stuck (for reference)
- **`stop_player`:** Some(player) if someone hit 31 (Stop the Bus)
- **`pending_new_round`:** Internal flag for round transition

**Game State:**
- **`next_start_candidate`:** Next player to start a round (rotates)
- **`finished`:** True when game is over
- **`rng`:** Seeded random number generator (for deterministic testing)

**Human Interaction State:**
- **`awaiting_human`:** True when automation paused for player 0
- **`human_old_stack_card`:** Card on stack when human turn began (prevents draw-after-swap)
- **`human_can_draw_next`:** True if human can advance stack (disallowed after swap)
- **`human_can_stick`:** True if human can stick (requires nobody stuck yet)

---

## Public API Reference

### Construction and Initialization

#### `GameState::new(seed: Option<u64>) -> Self`
Creates new game with 3 lives per player and shuffled deck.
- **seed:** Some(value) for deterministic testing, None for random
- **Returns:** Initialized game state (not started)

**Example:**
```rust
let game = GameState::new(None); // Random seed
let test_game = GameState::new(Some(42)); // Deterministic for testing
```

---

#### `GameState::default() -> Self`
Equivalent to `GameState::new(None)`.

---

#### `start_game(&mut self)`
Resets game to initial state with fresh lives (3 per player).
- Clears hands, scores, round state
- Shuffles deck
- Does NOT advance game (call `start_new_round()` next)

---

#### `start_fresh(&mut self) -> DriveReport`
Convenience method: calls `start_game()` then immediately starts first round.
- **Returns:** DriveReport with events and current state
- **Use Case:** Starting a brand-new game from scratch

**Example:**
```rust
let mut game = GameState::new(None);
let report = game.start_fresh();
// Game is now running, potentially awaiting human
```

---

#### `start_new_round(&mut self) -> DriveReport`
Starts a new round without resetting lives.
- Shuffles and deals cards
- Determines starting player (rotates)
- Processes AI turns until human input needed or round ends
- **Returns:** DriveReport with events

**Use Case:** Called internally after round finishes, or manually to continue game.

---

### Game Progression

#### `advance_after_human_turn(&mut self) -> DriveReport`
Call this after human completes their turn.
- Ends human turn state
- Advances to next alive player
- Processes AI turns until human needed again or round/game ends
- **Returns:** DriveReport with subsequent events

**Usage Pattern:**
```rust
// Human swapped a card or stuck
game.human_swap_with_stack(1)?; // Returns idle report
let report = game.advance_after_human_turn(); // Continue automation
```

---

#### `continue_automation(&mut self) -> DriveReport`
Continues automated play if game paused mid-AI-sequence.
- **Use Case:** Rare; typically game doesn't pause during AI turns
- **Returns:** DriveReport

---

### Human Player Actions

#### `human_swap_with_stack(&mut self, slot: usize) -> Option<DriveReport>`
Swaps human's card at `slot` (0-2) with top stack card.
- **Validates:**
  - Human turn active (`awaiting_human`)
  - Human not knocked out (`lives[0] > 0`)
  - Valid slot index (0-2)
  - Card exists in slot
- **Side Effects:**
  - Swaps cards
  - Updates scores
  - Disables `human_can_draw_next` (unless stack unchanged)
  - Refreshes `human_can_stick` flag
- **Returns:**
  - `Some(idle_report)` on success (no events, still awaiting human)
  - `None` if invalid

**Example:**
```rust
if let Some(_) = game.human_swap_with_stack(0) {
    // Swap succeeded, human can stick or advance
}
```

---

#### `human_draw_next_card(&mut self) -> Option<DriveReport>`
Advances stack pointer to reveal next card (instead of swapping).
- **Validates:**
  - `awaiting_human` and `human_can_draw_next` both true
  - Stack card hasn't changed since turn began
  - Not at end of deck
- **Side Effects:**
  - Increments `stack_index`
  - Disables `human_can_draw_next` and `human_can_stick`
  - Updates scores
- **Returns:**
  - `Some(idle_report)` on success
  - `Some(DriveReport)` with "Deck overflow" alert if at end
  - `None` if invalid

**Use Case:** Human doesn't like current stack card, wants to see next one.

---

#### `human_stick(&mut self) -> Option<DriveReport>`
Marks human as sticking for the round.
- **Validates:**
  - `awaiting_human` and `human_can_stick` both true
- **Side Effects:**
  - Sets `stick_player = Some(0)` and `stick_player_score`
  - Calls `advance_after_human_turn()` to continue automation
- **Returns:**
  - `Some(DriveReport)` with subsequent events
  - `None` if invalid

**Usage Pattern:**
```rust
if game.human_can_stick() {
    if let Some(report) = game.human_stick() {
        // Automation continues, process report
    }
}
```

---

#### `apply_stick(&mut self, player: usize) -> bool`
Low-level method to mark any player as sticking.
- **player:** Player index (0-3)
- **Returns:** `true` if successful, `false` if invalid
- **Use Case:** Typically internal, but exposed for flexibility

---

### State Query Methods

#### `lives(&self) -> &[u8; PLAYERS]`
Returns reference to life counters array [0..3].

---

#### `awaiting_human(&self) -> bool`
True if game paused waiting for player 0 input.

---

#### `human_can_stick(&self) -> bool`
True if human can stick right now (nobody stuck yet, human's turn).

---

#### `current_player(&self) -> usize`
Returns index of active player (0-3).

---

#### `round_start_player(&self) -> usize`
Returns who started the current round.

---

#### `stick_player(&self) -> Option<usize>`
Returns Some(player) if someone has stuck, None otherwise.

---

#### `stack_index(&self) -> usize`
Returns current position in deck (for UI rendering).

---

#### `stack_top_card(&self) -> Option<CardId>`
Returns top card of stack (card at `stack_index`).

---

#### `update_round_scores(&mut self)`
Recalculates `round_scores` for all alive players.
- Called automatically after swaps
- Exposed for manual refresh if needed

---

#### `lowest_alive_score(&self) -> Option<u8>`
Returns minimum score among alive players (for round-end logic).

---

#### `player_has_stop_the_bus(&self, player: usize) -> bool`
True if specified player has score == 31.

---

#### `set_lives(&mut self, lives: [u8; PLAYERS])`
Manually sets life counters (for testing or custom scenarios).
- Clears `finished` flag

---

## Game Logic Algorithms

### Deck Shuffling

**Function:** `shuffle_deck()` (lines 879-889)

**Algorithm:**
1. Reset deck to ordered state (1-52)
2. Perform **100 iterations** of Fisher-Yates shuffle:
   - Pick two random indices `a` and `b`
   - Swap `deck[a]` with `deck[b]`
3. Reset `stack_index` to 0

**Why 100 Iterations?**
- Matches original Pascal implementation exactly
- Ensures thorough randomization
- Historical compatibility with 1993 version

**RNG:**
- Uses `StdRng` from `rand` crate
- Seeded in constructor (deterministic if seed provided)

---

### Card Scoring

#### **Card Rank Extraction**
```rust
pub fn card_rank(card: CardId) -> Option<u8>
```
- **Formula:** `((card - 1) % 13) + 1`
- **Returns:** 1 (Ace) through 13 (King)
- **Example:** Card 14 (Diamonds Ace) ’ rank 1

---

#### **Card Suit Extraction**
```rust
pub fn card_suit(card: CardId) -> Option<Suit>
```
- **Formula:** `(card - 1) / 13`
  - 0 ’ Clubs
  - 1 ’ Diamonds
  - 2 ’ Hearts
  - 3 ’ Spades

---

#### **Card Point Values**
```rust
pub fn card_points(card: CardId) -> u8
```
- **Ace (rank 1):** 11 points
- **Jack, Queen, King (ranks 11-13):** 10 points each
- **All others (ranks 2-10):** Face value

**Matches Pascal ValScore function exactly.**

---

#### **Hand Scoring Algorithm**
```rust
pub fn hand_max_score(cards: &[Option<CardId>; HAND_SIZE]) -> u8
```

**Purpose:** Calculate best score from a 3-card hand

**Strategy:** Try each card as a "base" and sum all same-suit cards
1. Iterate through each card in hand
2. For each card:
   - Get its suit and point value
   - Add points from other cards of the same suit
   - Track maximum score
3. Return highest score found

**Example:**
- Hand: [Acec, 2c, 3c] ’ Clubs total = 11+2+3 = **16**
- Hand: [Acec, Acef, Acee] ’ Best single card = **11**
- Hand: [Acee, 10e, Kinge] ’ Hearts total = 11+10+10 = **31** (Stop the Bus!)

**Matches Pascal GetScore function exactly.**

---

#### **Stop the Bus Detection**
```rust
pub fn player_stop_the_bus(cards: &[Option<CardId>; HAND_SIZE]) -> bool
```
Returns `hand_max_score(cards) == 31`

**Significance:** Score of 31 immediately ends the round, all other players lose a life.

---

### Dealing Cards

**Function:** `deal_round()` (lines 891-912)

**Algorithm:**
1. Shuffle deck (100-iteration Fisher-Yates)
2. Deal cards slot-by-slot to alive players:
   - For each hand slot (0-2):
     - For each player (0-3):
       - If player has lives > 0: deal card from deck
       - Else: set hand slot to None
3. Set `stack_index` to first undealt card
4. Update round scores

**Key Behavior:**
- Dead players (lives == 0) receive no cards
- Alive players get exactly 3 cards
- Stack starts after last dealt card

**Example with 2 alive players:**
- Player 0: alive ’ gets cards 0, 1, 2
- Player 1: dead ’ gets None, None, None
- Player 2: alive ’ gets cards 3, 4, 5
- Player 3: dead ’ gets None, None, None
- `stack_index` = 6

---

### AI Turn Logic

**Function:** `execute_auto_turn()` (lines 746-771)

**Purpose:** Execute one AI player's turn

**Algorithm (matches Pascal AutoPlay):**

1. **Check Stick Condition:**
   - If nobody has stuck yet AND player's score > 25:
     - Mark player as sticking
     - End turn
     - Return

2. **First Swap Attempt:**
   - Try swapping each hand slot with current stack card
   - Find best improvement
   - **Conditions to swap:**
     - `new_score > base_score` AND
     - `new_score > 6`
   - If swap made:
     - End turn
     - Return

3. **Advance Stack:**
   - Increment `stack_index` to reveal next card
   - If deck overflow:
     - End turn
     - Return

4. **Second Swap Attempt:**
   - Try swapping with new stack card
   - **Conditions to swap:**
     - `new_score > base_score` (no minimum requirement)
   - Swap if improvement found

5. **End Turn**

**Key Differences from Human:**
- AI uses two-stage strategy (conservative then aggressive)
- AI automatically sticks at >25
- AI never draws multiple cards
- No confirmation required

**Matches Pascal AutoPlay logic exactly (lines 1328-1451 in STOPBUS.PAS).**

---

### Round Completion Logic

**Function:** `finish_round()` (lines 579-686)

**Purpose:** Determine who loses lives and whether game ends

**Algorithm:**

1. **Update all scores**

2. **Determine life losses:**
   - **If Stop the Bus occurred (score == 31):**
     - All players EXCEPT stopper lose a life
   - **Else (normal round end):**
     - All players with lowest score lose a life

3. **Decrement lives and track knockouts:**
   - For each losing player:
     - Decrement `lives[player]`
     - Track if they were knocked out (lives ’ 0)

4. **Generate event messages:**
   - If stopper: "Player X stopped the bus."
   - If life losses: "Player X and Player Y lost a life."
   - If knockouts: "Player X has been knocked out."

5. **Check game-over conditions:**
   - **0 alive:** Draw declared ’ GameOver
   - **1 alive:** Winner declared ’ GameOver
   - **2+ alive:** Continue ’ new round queued

6. **Reset round state:**
   - Clear `stop_player`, `stick_player`
   - Reset human turn flags

**Special Messages:**
- Draw: "A draw is declared. That was a rare message - well done!"
- Winner: "Congratulations - you've won!" or "Player X has won."

**Return Value:** `FinishResult` enum

---

### Round Start Player Rotation

**Function:** `next_alive_after()` (lines 914-922)

**Purpose:** Find next alive player after given index

**Algorithm:**
- Iterate circularly through players (start+1, start+2, ..., start+PLAYERS)
- Return first player with `lives > 0`
- Return None if all dead

**Usage:**
- Determines round start player (rotates each round)
- Skips dead players during turn progression

---

### Human Turn Management

#### **Begin Human Turn**
**Function:** `begin_human_turn()` (lines 376-381)

**Actions:**
1. Set `awaiting_human = true`
2. Set `human_can_draw_next = true` (allow advancing stack)
3. Capture `human_old_stack_card` (prevent draw after swap)
4. Refresh `human_can_stick` flag (true if nobody stuck yet)

---

#### **End Human Turn**
**Function:** `end_human_turn()` (lines 383-389)

**Actions:**
1. Clear all human state flags
2. Call `complete_turn()` (increment turn counter)

---

#### **Refresh Stick Flag**
**Function:** `refresh_human_stick_flag()` (lines 851-861)

**Logic:**
- Can stick IF:
  - Human turn active
  - Human has lives > 0
  - Stack card hasn't changed since turn began
  - Nobody has stuck yet

**Purpose:** Disallow sticking after drawing next card

---

## Internal State Machine

### Game Flow Diagram (Textual)

```
GameState::new()
    “
start_fresh() ’ start_game() ’ start_new_round()
    “                               “
    “                         shuffle & deal
    “                               “
    “                         set current_player
    “                               “
    “                         drive_round_step()        
    “                               “                    
    “                              4                   
    “                                                  
    “                   Current = 0?   Current = AI      
    “                                                  
    “                   begin_human   execute_auto_turn  
    “                                                  
    “                   return DriveReport   next_player 
    “                   (awaiting_human)                 
    “                         
    “                   [USER ACTION]
    “                         
    “                   human_swap_with_stack() / human_stick()
    “                         
    “                   advance_after_human_turn()
    “                         
                              (loop back to drive_round_step)
```

### Round End Conditions

1. **Stop the Bus Detected:**
   - Any player reaches score 31
   - Immediately ends round
   - Stopper safe, all others lose life

2. **Stick Returned:**
   - Player sticks (marks `stick_player`)
   - Round continues until turn comes back to sticker
   - Lowest scorers lose life

3. **All Players Passed:**
   - Circular pass completion (rare)
   - Lowest scorers lose life

### Game End Conditions

1. **Single Survivor:**
   - Only one player has lives > 0
   - Winner declared

2. **All Knocked Out:**
   - All players reach lives == 0 (rare)
   - Draw declared

---

## Testing Infrastructure

### Unit Tests (lines 1011-1071)

**Test Coverage:**

#### 1. `ranks_and_suits`
Validates card encoding:
- Card 1 ’ Rank 1 (Ace), Suit Clubs
- Card 13 ’ Rank 13 (King), Suit Clubs
- Card 14 ’ Rank 1 (Ace), Suit Diamonds
- Cards 27, 40 ’ Hearts, Spades

---

#### 2. `value_scoring_matches_pascal_logic`
Validates point values:
- Ace ’ 11
- Jack/Queen/King ’ 10 each
- Others ’ face value

---

#### 3. `hand_scoring_respects_best_suit`
Validates scoring algorithm:
- Mixed suits: best single-card value
- Same suit: sum of all same-suit cards
- Example: [Ac, Af, Ae] ’ 11 (not 33)
- Example: [Ac, 2c, 3c] ’ 16 (sum)

---

#### 4. `detect_stop_the_bus`
Validates 31-detection:
- [Ae, 10e, Ke] ’ true (11+10+10 = 31)
- Mixed cards ’ false

---

#### 5. `deal_respects_lives`
Validates dealing with dead players:
- Alive players get 3 cards
- Dead players get None
- Stack starts after last dealt card
- Scores calculated only for alive players

---

### Testing with Seeded RNG

**Pattern:**
```rust
let mut game = GameState::new(Some(42)); // Deterministic shuffle
game.set_lives([3, 0, 1, 0]); // Custom starting lives
game.deal_round(); // Repeatable card distribution
// Assert expected state
```

**Benefits:**
- Reproducible tests
- Isolate game logic from randomness
- Test edge cases (specific card combinations)

---

## Dependencies

### External Crates

**`rand = "0.8"` with `std` feature:**
- **Usage:** Deck shuffling via `StdRng`
- **Why:** Deterministic testing support (seed_from_u64)
- **Location:** Lines 1-2, 73, 92-95, 883-884

**Standard Library:**
- **Option<T>:** Card slots (None for empty), player states
- **Vec<T>:** Event collections, turn sequences
- **Arrays:** Fixed-size player/hand/deck data

---

## Code Organization

### Public API (Exported Items)
- Type aliases: `CardId`
- Constants: `DECK_SIZE`, `PLAYERS`, `HAND_SIZE`
- Enums: `Suit`, `MessageKind`
- Structs: `GameEvent`, `DriveReport`, `GameState`
- Functions: `card_rank()`, `card_suit()`, `card_points()`, `hand_max_score()`, `player_stop_the_bus()`

### Private Implementation
- Struct: `LifeLossInfo` (round-end tracking)
- Enum: `FinishResult` (internal state transitions)
- Functions: All GameState methods prefixed with `impl GameState`
- Helper: `ordered_deck()`, player name formatting, sentence joining

### Testing Module
- `#[cfg(test)] mod tests` (lines 1011-1071)
- 5 unit tests covering core mechanics

---

## Comparison with Legacy Pascal

### Preserved Behaviors

| Feature | Pascal (STOPBUS.PAS) | Rust (stopbus-core) |
|---------|----------------------|---------------------|
| Card encoding | 1-52 (Clubs to Spades) | Identical |
| Shuffle iterations | 100 | 100 (exact match) |
| Scoring | ValScore, GetScore | card_points, hand_max_score |
| AI stick threshold | >25 | >25 |
| AI swap logic | Two-stage, >5 and >6 | Identical |
| Stop the Bus | Score == 31 | Identical |
| Life system | 3 lives, decrement | Identical |

### Architectural Improvements

| Aspect | Pascal | Rust |
|--------|--------|------|
| State storage | Global arrays | Encapsulated struct |
| Type safety | Weak (INTEGER, BOOLEAN) | Strong (enums, Option<T>) |
| Memory management | Manual (New/Dispose) | Automatic (ownership) |
| Error handling | Nil checks | Option<T>, Result<T,E> |
| Testing | Manual VM testing | Unit tests with seeded RNG |
| UI coupling | Mixed (TMainWindow) | Separated (no UI deps) |

### Pascal Mapping Reference

| Pascal Function | Rust Equivalent | Location |
|-----------------|-----------------|----------|
| Shuffle | shuffle_deck() | lines 879-889 |
| Deal | deal_round() | lines 891-912 |
| ValScore | card_points() | lines 971-977 |
| GetScore | hand_max_score() | lines 979-1005 |
| AutoPlay | execute_auto_turn() | lines 746-771 |
| GameControl | drive_round_step() | lines 391-555 |
| Scores | finish_round() | lines 579-686 |
| StopTheBus | detect_stop_bus() | lines 556-577 |

---

## Technical Debt and Future Improvements

### Current Limitations

1. **No Cheat Mode:**
   - Original Pascal had cheat windows (show AI hands, stack preview)
   - Not implemented in core library
   - **Rationale:** UI-specific feature, could be added to UI layer

2. **Limited Configuration:**
   - No toggles for house rules (e.g., different starting lives)
   - **Future:** Add `GameConfig` struct

3. **No Undo/Replay:**
   - Cannot rewind turns
   - **Future:** Event sourcing pattern

4. **Fixed Player Count:**
   - Always 4 players (const PLAYERS = 4)
   - **Consideration:** Making this configurable would break Pascal compatibility

5. **No Save/Load:**
   - Cannot serialize game state
   - **Future:** Implement Serialize/Deserialize traits (serde)

### Testing Gaps

1. **Edge Case Coverage:**
   - Deck overflow handling (tested manually, not unit tested)
   - All-player knockout scenarios (tested in finish_round logic)
   - Simultaneous stick/stop interactions

2. **Integration Tests:**
   - Full game simulations (from start to game-over)
   - AI vs. AI games (validate no hangs)

3. **Property-Based Testing:**
   - Randomized games with invariant checks (e.g., score always 0-31)

### Performance Considerations

- **Current:** 100-iteration shuffle (matches Pascal)
- **Modern:** 52-iteration Fisher-Yates would suffice
- **Decision:** Preserve Pascal behavior for historical accuracy

---

## Usage Examples

### Basic Game Loop

```rust
use stopbus_core::GameState;

fn main() {
    let mut game = GameState::new(None);
    let mut report = game.start_fresh();

    loop {
        // Display events
        for event in &report.events {
            println!("[{}] {}",
                if event.kind == MessageKind::Alert { "ALERT" } else { "INFO" },
                event.text
            );
        }

        // Check game over
        if report.game_over() {
            if let Some(winner) = report.winner {
                println!("Winner: Player {}", winner + 1);
            } else if report.draw {
                println!("Game ended in a draw!");
            }
            break;
        }

        // Handle human turn
        if report.awaiting_human {
            // ... UI interaction here ...
            // Example: swap card 0 with stack
            if let Some(_) = game.human_swap_with_stack(0) {
                report = game.advance_after_human_turn();
            }
        } else {
            // Continue AI turns
            report = game.continue_automation();
        }
    }
}
```

### Deterministic Testing

```rust
#[test]
fn test_specific_scenario() {
    let mut game = GameState::new(Some(12345));
    game.set_lives([3, 3, 0, 0]); // 2-player game

    let report = game.start_new_round();
    // With this seed, we know exact cards dealt

    // Validate expected behavior
    assert!(report.awaiting_human);
    assert_eq!(game.current_player(), 0);
}
```

---

## Summary

The `stopbus-core` crate provides a robust, well-tested foundation for the "Stop the Bus" game. It successfully preserves the original 1993 Pascal logic while modernizing the architecture with Rust's safety guarantees and clean API design.

**Strengths:**
- Clean separation from UI (testable in isolation)
- Faithful port of Pascal game mechanics
- Type-safe state management
- Comprehensive public API
- Deterministic testing support

**Next Steps for Full Parity:**
- Implement UI layer in stopbus-ui
- Wire UI events to core API calls
- Add configuration persistence (Registry/INI)
- Implement cheat mode visualization
- Expand test coverage for edge cases

---

**Document Created:** 2025-11-06
**Author:** Claude Code (Sonnet 4.5)
