# Migration & Updating Plan — 20 September 2025

## 1. Objectives
- Preserve the original Turbo Pascal for Windows release as a documented artifact.
- Deliver a feature-parity Rust rewrite using the `windows` crate (windows-rs) targeting modern Windows.
- Modernize assets (resources, help content, packaging) while keeping historical fidelity where feasible.

## 2. Current State Assessment
- Source: `STOPBUS.PAS` (main UI and game logic), `CTL3D.PAS` (3-D control shim), backups (`STOPBUS.BAK`, `STOPBUS.~RE`).
- Resources: `ABOUT.RC`, compiled `STOPBUS.RES`, icon `MD.ICO`, WinHelp project (`HELP/STOPBUS.HPJ`, `STOPBUS.RTF`, bitmaps in `HELP/BMP.ZIP`).
- Binaries: Legacy `STOPBUS.EXE`, `STOPBUS.HLP`, shareware documentation `STOPBUS.TXT`.
- Build tooling: Borland Turbo Pascal for Windows 1.5 workflow plus Microsoft Help Compiler.

## 3. Target Architecture Overview
- Language/Runtime: Rust (stable channel) with `windows = "0.58"` (or latest) for Win32 bindings.
- Project Layout: Cargo workspace with crates `stopbus-core` (game logic), `stopbus-ui` (Win32 shell), `stopbus-resources` (build script + assets).
- UI Layer: Retained Win32 APIs initially; potential future exploration of WinUI 3 once parity achieved.
- Packaging: Produce signed MSIX or ZIP containing `stopbus.exe`, converted help (HTML/Markdown), and resources; keep legacy ZIP reconstruction instructions.

## 4. Workstreams & Phasing
### Phase A — Reverse Engineering & Documentation (1-2 weeks)
- Catalogue window procedures, global variables, and message handlers in `STOPBUS.PAS`.
- Extract dialog/menu/resource IDs from `ABOUT.RC` and map to UI behavior.
- Record deck structure, scoring rules, life tracking, and configuration toggles.
- Output: Architecture note, event-flow diagram, resource inventory.

### Phase B — Asset Extraction & Conversion (1 week)
- Decompile `STOPBUS.RES` with tools like `Resource Hacker` to obtain dialogs, menus, accelerators.
- Unpack `HELP/BMP.ZIP`; convert BMPs to PNG while retaining originals.
- Decide on help migration (HTML files + in-app viewer vs. markdown in docs); produce conversion proof-of-concept.
- Output: `assets/` folder with cleaned resources, conversion scripts.

### Phase C — Rust Project Bootstrap (1 week)
- Initialize Cargo workspace with binaries and core library.
- Add `windows` bindings for Win32 base functions, register window class, seed message loop.
- Integrate resource build pipeline using `windows-resource` or `cargo winres` to embed icon/version data.
- Output: Minimal Rust app displaying empty main window and About dialog stub.

### Phase D — Core Logic Port (2-3 weeks)
- Translate deck and scoring logic from Pascal into `stopbus-core`, backed by unit tests replicating original behavior.
- Implement player state machine, turn sequencing, and life tracking.
- Port configuration options (cheat toggles, save-on-exit flags) into serializable Rust structs.
- Output: Tested core library with parity against known Pascal outcomes.

### Phase E — UI & Interaction Layer (2-3 weeks)
- Wire menu commands, toolbars, and dialogs using Win32 wrappers from windows-rs.
- Recreate CTL3D visual treatment via manifest or custom theme hooks.
- Hook up event handlers to core logic; ensure drag/drop card interactions mimic original.
- Output: Playable Rust build feature-matching the 1994 UI.

### Phase F — Help & Documentation Refresh (1 week)
- Replace WinHelp with modern help content (HTML or markdown rendered in-app or browser).
- Update `STOPBUS.TXT` and new docs describing toolchain, rebuild steps, and shareware history.
- Output: `docs/` folder, updated `AGENTS.md`, finalized user help.

### Phase G — Packaging & QA (1-2 weeks)
- Automate build scripts (GitHub Actions or Azure Pipelines) for debug/release artifacts.
- Create MSI/MSIX or signed ZIP; include hashes and release notes.
- Conduct regression testing on Windows 10/11, optionally 32-bit VMs; capture screenshots and gameplay recordings.
- Output: Release candidate package, QA checklist, automated CI.

## 5. Dependencies & Tooling
- Rust toolchain (stable), `cargo`, `windows` crate.
- Resource tools: `cargo-winres`, `Resource Hacker`, `windres` (optional).
- Help conversion: Pandoc or custom script; markdown viewer if embedded.
- Testing: Windows VMs, `certutil` for hashes, possible screenshot automation (WinAppDriver).
- Legacy reference environment: Windows 3.1/95 VM with TPW 1.5 for verification.

## 6. Risks & Mitigations
- **Pascal semantics divergence:** Validate port with unit tests using captured Pascal outputs; keep legacy EXE for comparison.
- **WinHelp obsolescence:** Provide alternate help UX early; keep original `.HLP` archived.
- **Resource fidelity:** Use pixel-perfect exports; consider bundling original BMPs to preserve aesthetics.
- **Toolchain availability:** Document how to obtain TPW legally for archival testing; rely on Rust toolchain for new builds.
- **Timeline creep:** Timebox phases; prioritize core gameplay parity before elective UI modernization.

## 7. Immediate Action Items
1. Write detailed architecture notes from `STOPBUS.PAS` and `ABOUT.RC` (assign to Volunteer A).
2. Set up Rust workspace skeleton with minimal window (Volunteer B).
3. Inventory help assets and test conversion pipeline (Volunteer C).
4. Update `AGENTS.md` and repository README with modernization roadmap reference (Volunteer A).

## 8. Success Criteria
- Rust build runs native on Windows 10/11 with gameplay identical to legacy version.
- Automated build/test pipeline produces reproducible artifacts and checksum reports.
- Legacy assets remain preserved with documentation of provenance and differences.
- Contributors can on-board via `AGENTS.md` and the new migration docs within one sprint.
